{"id":407319,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC80MDczMTk=","url":"https://hackerone.com/reports/407319","title":"ActiveStorage service's signed URLs can be hijacked via AppCache+Cookie stuffing trick when using GCS or DiskService","state":"Closed","substate":"resolved","severity_rating":"high","readable_substate":"Resolved","created_at":"2018-09-07T20:39:10.582Z","submitted_at":"2018-09-07T20:39:10.582Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"rosa","url":"/rosa","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/154/237/a07aeeba083a8f178942d326a68f6427c699e0f1_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":22,"url":"https://hackerone.com/rails","handle":"rails","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/000/022/5e2b46658c8b86bed62f574d8e1793f353cbbc63_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/022/5e2b46658c8b86bed62f574d8e1793f353cbbc63_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Ruby on Rails","twitter_handle":null,"website":"http://rubyonrails.org/security","about":"Web development that doesn't hurt."}},"has_bounty?":false,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":["CVE-2018-16477"],"singular_disclosure_disabled":false,"disclosed_at":"2018-12-27T21:27:02.574Z","bug_reporter_agreed_on_going_public_at":null,"team_member_agreed_on_going_public_at":"2018-11-27T21:27:00.676Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"`ActiveStorage` tries to force `content-disposition: attachment` for [a list of content-types](https://github.com/rails/rails/blob/2a470d73a75ebf8cd7975e469bd82586d9234442/activestorage/lib/active_storage/engine.rb#L33-L42), including `text/html`. However, `response-content-type` and `response-content-disposition` in GCS and DiskService's URLs aren't signed, which means an attacker can modify them at will. This is not the case for Azure or S3.\n\nThis can be exploited using `AppCache` and cookie bombing as follows:\n1. Upload the following file as `ActiveStorage::Blob`\nFile: fallback.html\n```\n\u003chtml\u003e\n\u003cscript\u003e\n  alert('Your request to the page '+location.href+' is hijacked!');\n\u003c/script\u003e\n\u003c/html\u003e\n```\nGrab the service signed URL for it and modify content type and content disposition params to `text/html` and `inline`. \n\n2. Now upload this other file using that URL as fallback:\nFile: manifest.appcache\n```\nCACHE MANIFEST \nFALLBACK:\n/bucket_name/ [fallback_url from previous step]\n```\nIn the same way, grab the signed service URL and modify content disposition and type to ensure it's served inline and as `text/cache-manifest`. \n\n3. Finally, upload this file using the service URL for manifest.appcache:\nFile: main.html\n```\n\u003chtml manifest=\"[manifest_url from the manifest above]\"\u003e\nAny requests to this bucket will be hijacked.\n\u003cscript\u003e\nsetTimeout(function(){\nfor(var i = 1e3; i\u003e0; i--){document.cookie = i + '=' + Array(4e3).join('0') + '; path=/'};\n}, 3000);\n\u003c/script\u003e\n\u003c/html\u003e\n```\nGrab the service URL for `main.html`, modify content type and disposition to ensure it's served as `inline` and `text/html`, and trick a user of the Rails app with access to `ActiveStorage` attachments into clicking it.\n\nSince it'll be open inline and as HTML, the JS code to overflow the cookies for the service (storage.googleapis.com in the case of GCS) will be executed. Next time the user makes a request for a file under the same bucket as `main.html`, googleapis.com will return an error due to the size of the cookie headers. This will be interpreted as being offline by the browser, which will offer the fallback specified in the manifest.  The `fallback.html` above will be opened inline and as HTML as well, and its JS code executed. That code can be made to send `location.href` (the signed URL)  to the attacker.\n\n## Impact\n\nGain access to signed URLs for private objects, which in practice means access to those objects, as signed URLs is all that is needed.","vulnerability_information_html":"\u003cp\u003e\u003ccode\u003eActiveStorage\u003c/code\u003e tries to force \u003ccode\u003econtent-disposition: attachment\u003c/code\u003e for [a list of content-types](), including \u003ccode\u003etext/html\u003c/code\u003e. However, \u003ccode\u003eresponse-content-type\u003c/code\u003e and \u003ccode\u003eresponse-content-disposition\u003c/code\u003e in GCS and DiskService\u0026#39;s URLs aren\u0026#39;t signed, which means an attacker can modify them at will. This is not the case for Azure or S3.\u003c/p\u003e\n\n\u003cp\u003eThis can be exploited using \u003ccode\u003eAppCache\u003c/code\u003e and cookie bombing as follows:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eUpload the following file as \u003ccode\u003eActiveStorage::Blob\u003c/code\u003e\u003cbr\u003e\nFile: fallback.html\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight html\"\u003e\u003ccode\u003e\u003cspan class=\"nt\"\u003e\u0026lt;html\u0026gt;\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e\u0026lt;script\u0026gt;\u003c/span\u003e\n\u003cspan class=\"nx\"\u003ealert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eYour request to the page \u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"nx\"\u003elocation\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ehref\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e is hijacked!\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e\u0026lt;/script\u0026gt;\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e\u0026lt;/html\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eGrab the service signed URL for it and modify content type and content disposition params to \u003ccode\u003etext/html\u003c/code\u003e and \u003ccode\u003einline\u003c/code\u003e. \u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNow upload this other file using that URL as fallback:\u003cbr\u003e\nFile: manifest.appcache\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eCACHE MANIFEST \nFALLBACK:\n/bucket_name/ [fallback_url from previous step]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIn the same way, grab the signed service URL and modify content disposition and type to ensure it\u0026#39;s served inline and as \u003ccode\u003etext/cache-manifest\u003c/code\u003e. \u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFinally, upload this file using the service URL for manifest.appcache:\u003cbr\u003e\nFile: main.html\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight html\"\u003e\u003ccode\u003e\u003cspan class=\"nt\"\u003e\u0026lt;html\u003c/span\u003e \u003cspan class=\"na\"\u003emanifest=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026quot;[manifest_url from the manifest above]\u0026quot;\u003c/span\u003e\u003cspan class=\"nt\"\u003e\u0026gt;\u003c/span\u003e\nAny requests to this bucket will be hijacked.\n\u003cspan class=\"nt\"\u003e\u0026lt;script\u0026gt;\u003c/span\u003e\n\u003cspan class=\"nx\"\u003esetTimeout\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kd\"\u003evar\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"nx\"\u003ee3\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\u003cspan class=\"nb\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ecookie\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e=\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"nb\"\u003eArray\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"nx\"\u003ee3\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"nx\"\u003ejoin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e0\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e; path=/\u003c/span\u003e\u003cspan class=\"dl\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003cspan class=\"p\"\u003e},\u003c/span\u003e \u003cspan class=\"mi\"\u003e3000\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e\u0026lt;/script\u0026gt;\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e\u0026lt;/html\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eGrab the service URL for \u003ccode\u003emain.html\u003c/code\u003e, modify content type and disposition to ensure it\u0026#39;s served as \u003ccode\u003einline\u003c/code\u003e and \u003ccode\u003etext/html\u003c/code\u003e, and trick a user of the Rails app with access to \u003ccode\u003eActiveStorage\u003c/code\u003e attachments into clicking it.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eSince it\u0026#39;ll be open inline and as HTML, the JS code to overflow the cookies for the service (storage.googleapis.com in the case of GCS) will be executed. Next time the user makes a request for a file under the same bucket as \u003ccode\u003emain.html\u003c/code\u003e, googleapis.com will return an error due to the size of the cookie headers. This will be interpreted as being offline by the browser, which will offer the fallback specified in the manifest.  The \u003ccode\u003efallback.html\u003c/code\u003e above will be opened inline and as HTML as well, and its JS code executed. That code can be made to send \u003ccode\u003elocation.href\u003c/code\u003e (the signed URL)  to the attacker.\u003c/p\u003e\n\n\u003ch2 id=\"impact\"\u003eImpact\u003c/h2\u003e\n\n\u003cp\u003eGain access to signed URLs for private objects, which in practice means access to those objects, as signed URLs is all that is needed.\u003c/p\u003e\n","weakness":{"id":18,"name":"Information Disclosure"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2018-12-27T21:27:00.731Z","allow_singular_disclosure_after":-63275134.602783635,"singular_disclosure_allowed":true,"vote_count":4,"voters":["lightangel1412","foobar7","mygf","reddmist"],"severity":{"rating":"high","score":7.4,"author_type":"Team","metrics":{"attack_vector":"network","attack_complexity":"low","privileges_required":"none","user_interaction":"required","scope":"changed","confidentiality":"high","integrity":"none","availability":"none"}},"structured_scope":{"databaseId":160,"asset_type":"SOURCE_CODE","asset_identifier":"https://github.com/rails/rails","max_severity":"critical"},"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":3319837,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"I forgot to add that the attack only works until the signed service URLs used in it expire, which is [set to 5 minutes by default](https://github.com/rails/rails/blob/e8682c5bf051517b0b265e446aa1a7eccfd47bf7/activestorage/lib/active_storage/engine.rb#L57). This makes it quite hard to apply in practice, at least broadly (unless, of course, the expiration time is configured in a specific app to a longer time). With 5 minutes, it'd need to be very targeted for a user, and only a very limited number of signed URLs could be stolen in reality. ","markdown_message":"\u003cp\u003eI forgot to add that the attack only works until the signed service URLs used in it expire, which is [set to 5 minutes by default](). This makes it quite hard to apply in practice, at least broadly (unless, of course, the expiration time is configured in a specific app to a longer time). With 5 minutes, it\u0026#39;d need to be very targeted for a user, and only a very limited number of signed URLs could be stolen in reality. \u003c/p\u003e\n","automated_response":false,"created_at":"2018-09-11T07:43:52.144Z","updated_at":"2018-09-11T07:43:52.144Z","actor":{"username":"rosa","cleared":false,"url":"/rosa","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/154/237/a07aeeba083a8f178942d326a68f6427c699e0f1_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"rails","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3338471,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"@rafaelfranca yesterday I realised the PR I had opened to tackle this issue has a problem and the mitigation for GCS is not sufficient and can be easily bypassed. It's very easy to modify, though! When the CVE is ready and we can process I'll take care of that (and also of `DiskStorage`, for which I have some changes ready). ","markdown_message":"\u003cp\u003e\u003ca href=\"/rafaelfranca\"\u003e@rafaelfranca\u003c/a\u003e yesterday I realised the PR I had opened to tackle this issue has a problem and the mitigation for GCS is not sufficient and can be easily bypassed. It\u0026#39;s very easy to modify, though! When the CVE is ready and we can process I\u0026#39;ll take care of that (and also of \u003ccode\u003eDiskStorage\u003c/code\u003e, for which I have some changes ready). \u003c/p\u003e\n","automated_response":false,"created_at":"2018-09-14T15:50:45.773Z","updated_at":"2018-09-14T15:50:45.773Z","actor":{"username":"rosa","cleared":false,"url":"/rosa","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/154/237/a07aeeba083a8f178942d326a68f6427c699e0f1_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"rails","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3398220,"is_internal":false,"editable":false,"type":"Activities::ReportSeverityUpdated","message":"","markdown_message":"","automated_response":false,"created_at":"2018-09-27T18:12:47.899Z","updated_at":"2018-09-27T18:12:47.899Z","additional_data":{"old_severity":null,"new_severity":"High (7.4)","old_severity_id":null,"new_severity_id":215933},"actor":{"username":"rafaelfranca","cleared":false,"url":"/rafaelfranca","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/004/981/dd3b6bb41f9c33e3448ebbc47303f5a135f25105_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"rails","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3398221,"is_internal":false,"editable":false,"type":"Activities::BugTriaged","message":"","markdown_message":"","automated_response":false,"created_at":"2018-09-27T18:12:52.919Z","updated_at":"2018-09-27T18:12:52.919Z","actor":{"username":"rafaelfranca","cleared":false,"url":"/rafaelfranca","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/004/981/dd3b6bb41f9c33e3448ebbc47303f5a135f25105_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"rails","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3694822,"is_internal":false,"editable":false,"type":"Activities::CveIdAdded","message":"","markdown_message":"","automated_response":false,"created_at":"2018-11-21T21:20:45.995Z","updated_at":"2018-11-21T21:20:45.995Z","cve_ids":["CVE-2018-16477"],"actor":{"username":"rafaelfranca","cleared":false,"url":"/rafaelfranca","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/004/981/dd3b6bb41f9c33e3448ebbc47303f5a135f25105_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"rails","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3719120,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"","markdown_message":"","automated_response":false,"created_at":"2018-11-27T21:26:15.718Z","updated_at":"2018-11-27T21:26:15.718Z","actor":{"username":"rafaelfranca","cleared":false,"url":"/rafaelfranca","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/004/981/dd3b6bb41f9c33e3448ebbc47303f5a135f25105_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"reporter":{"username":"rosa","url":"/rosa"},"genius_execution_id":null,"team_handle":"rails","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3719134,"is_internal":false,"editable":false,"type":"Activities::NotEligibleForBounty","message":"","markdown_message":"","automated_response":false,"created_at":"2018-11-27T21:26:39.481Z","updated_at":"2018-11-27T21:26:39.481Z","actor":{"url":"/rails","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/022/5e2b46658c8b86bed62f574d8e1793f353cbbc63_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Ruby on Rails"}},"genius_execution_id":null,"team_handle":"rails","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3719135,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2018-11-27T21:27:00.701Z","updated_at":"2018-11-27T21:27:00.701Z","first_to_agree":true,"actor":{"username":"rafaelfranca","cleared":false,"url":"/rafaelfranca","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/004/981/dd3b6bb41f9c33e3448ebbc47303f5a135f25105_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"rails","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3897906,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2018-12-27T21:27:02.624Z","updated_at":"2018-12-27T21:27:02.624Z","actor":{"url":"/rails","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/022/5e2b46658c8b86bed62f574d8e1793f353cbbc63_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Ruby on Rails"}},"genius_execution_id":null,"team_handle":"rails","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"id":11811,"category":"team","content":"# Bypass vulnerability in Active Storage\n\nThere is a vulnerability in Active Storage. This vulnerability has been\nassigned the CVE identifier CVE-2018-16477.\n\nVersions Affected:  \u003e= 5.2.0\nNot affected:       \u003c 5.2.0\nFixed Versions:     5.2.1.1\n\nImpact\n------\nSigned download URLs generated by `ActiveStorage` for Google Cloud Storage\nservice and Disk service include `content-disposition` and `content-type`\nparameters that an attacker can modify. This can be used to upload specially\ncrafted HTML files and have them served and executed inline. Combined with\nother techniques such as cookie bombing and specially crafted AppCache manifests,\nan attacker can gain access to private signed URLs within a specific storage path.\n\nVulnerable apps are those using either GCS or the Disk service in production.\nOther storage services such as S3 or Azure aren't affected.\n\nAll users running an affected release should either upgrade or use one of the\nworkarounds immediately. For those using GCS, it's also recommended to run the\nfollowing to update existing blobs:\n\n```\nActiveStorage::Blob.find_each do |blob|\n  blob.send :update_service_metadata\nend\n```\n\nReleases\n--------\nThe FIXED releases are available at the normal locations.\n\nWorkarounds\n-----------\nPutting the following monkey patches in an intializer can help to mitigate the issue:\n\nFor GCS service:\n```\nrequire 'active_storage'\nrequire 'active_storage/service/gcs_service'\n\nmodule ActiveStorage\n  module GCSMetadata\n    def upload(key, io, checksum: nil, content_type: nil, disposition: nil, filename: nil)\n      instrument :upload, key: key, checksum: checksum do\n        begin\n          content_disposition = content_disposition_with(type: disposition, filename: filename) if disposition \u0026\u0026 filename\n          bucket.create_file(io, key, md5: checksum, content_type: content_type, content_disposition: content_disposition)\n        rescue Google::Cloud::InvalidArgumentError\n          raise ActiveStorage::IntegrityError\n        end\n      end\n    end\n\n    def update_metadata(key, content_type:, disposition: nil, filename: nil)\n      instrument :update_metadata, key: key, content_type: content_type, disposition: disposition do\n        file_for(key).update do |file|\n          file.content_type = content_type\n          if disposition \u0026\u0026 filename\n            file.content_disposition = content_disposition_with(type: disposition, filename: filename)\n          end\n        end\n      end\n    end\n  end\n\n  module StoreMetadata\n    def upload_without_unfurling(io)\n      service.upload key, io, checksum: checksum, **service_metadata\n    end\n\n    def identify\n      unless identified?\n        update! content_type: identify_content_type, identified: true\n        update_service_metadata\n      end\n    end\n\n    private\n      def service_metadata\n        if forcibly_serve_as_binary?\n          { content_type: \"application/octet-stream\", disposition: :attachment, filename: filename }\n        else\n          { content_type: content_type }\n        end\n      end\n\n      def update_service_metadata\n        service.update_metadata key, service_metadata if service_metadata.any?\n      end\n  end\nend\n\nRails.application.config.to_prepare do\n  ActiveStorage::Service::GCSService.prepend ActiveStorage::GCSMetadata\n  ActiveStorage::Blob.prepend ActiveStorage::StoreMetadata\nend\n```\n\nFor Disk service:\n```\nrequire 'active_storage'\nrequire 'active_storage/service/disk_service'\n\nmodule ActiveStorage\n  module GetParamsFromKey\n    def show\n      if key = decode_verified_key\n        serve_file disk_service.path_for(key[:key]), content_type: key[:content_type], disposition: key[:disposition]\n      else\n        super\n      end\n    rescue Errno::ENOENT\n      head :not_found\n    end\n  end\n\n  module IncludeParamsInKey\n    def upload(key, io, checksum: nil, **)\n      super(key, io, checksum: checksum)\n    end\n\n    def update_metadata(key, **)\n    end\n\n    def url(key, expires_in:, filename:, disposition:, content_type:)\n      instrument :url, key: key do |payload|\n        content_disposition = content_disposition_with(type: disposition, filename: filename)\n        verified_key_with_expiration = ActiveStorage.verifier.generate(\n          {\n            key: key,\n            disposition: content_disposition,\n            content_type: content_type\n          },\n          { expires_in: expires_in,\n          purpose: :blob_key }\n        )\n\n        generated_url = url_helpers.rails_disk_service_url(verified_key_with_expiration,\n          host: current_host,\n          disposition: content_disposition,\n          content_type: content_type,\n          filename: filename\n        )\n        payload[:url] = generated_url\n\n        generated_url\n      end\n    end\n  end\nend\n\nRails.application.config.to_prepare do\n  ActiveStorage::DiskController.prepend ActiveStorage::GetParamsFromKey\n  ActiveStorage::Service::DiskService.prepend ActiveStorage::IncludeParamsInKey\nend\n```","can_view?":true,"can_edit?":false,"content_html":"\u003ch1 id=\"bypass-vulnerability-in-active-storage\"\u003eBypass vulnerability in Active Storage\u003c/h1\u003e\n\n\u003cp\u003eThere is a vulnerability in Active Storage. This vulnerability has been\u003cbr\u003e\nassigned the CVE identifier CVE-2018-16477.\u003c/p\u003e\n\n\u003cp\u003eVersions Affected:  \u0026gt;= 5.2.0\u003cbr\u003e\nNot affected:       \u0026lt; 5.2.0\u003cbr\u003e\nFixed Versions:     5.2.1.1\u003c/p\u003e\n\n\u003ch2 id=\"impact\"\u003eImpact\u003c/h2\u003e\n\n\u003cp\u003eSigned download URLs generated by \u003ccode\u003eActiveStorage\u003c/code\u003e for Google Cloud Storage\u003cbr\u003e\nservice and Disk service include \u003ccode\u003econtent-disposition\u003c/code\u003e and \u003ccode\u003econtent-type\u003c/code\u003e\u003cbr\u003e\nparameters that an attacker can modify. This can be used to upload specially\u003cbr\u003e\ncrafted HTML files and have them served and executed inline. Combined with\u003cbr\u003e\nother techniques such as cookie bombing and specially crafted AppCache manifests,\u003cbr\u003e\nan attacker can gain access to private signed URLs within a specific storage path.\u003c/p\u003e\n\n\u003cp\u003eVulnerable apps are those using either GCS or the Disk service in production.\u003cbr\u003e\nOther storage services such as S3 or Azure aren\u0026#39;t affected.\u003c/p\u003e\n\n\u003cp\u003eAll users running an affected release should either upgrade or use one of the\u003cbr\u003e\nworkarounds immediately. For those using GCS, it\u0026#39;s also recommended to run the\u003cbr\u003e\nfollowing to update existing blobs:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003eActiveStorage::Blob.find_each do |blob|\n  blob.send :update_service_metadata\nend\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 id=\"releases\"\u003eReleases\u003c/h2\u003e\n\n\u003cp\u003eThe FIXED releases are available at the normal locations.\u003c/p\u003e\n\n\u003ch2 id=\"workarounds\"\u003eWorkarounds\u003c/h2\u003e\n\n\u003cp\u003ePutting the following monkey patches in an intializer can help to mitigate the issue:\u003c/p\u003e\n\n\u003cp\u003eFor GCS service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003erequire \u0026#39;active_storage\u0026#39;\nrequire \u0026#39;active_storage/service/gcs_service\u0026#39;\n\nmodule ActiveStorage\n  module GCSMetadata\n    def upload(key, io, checksum: nil, content_type: nil, disposition: nil, filename: nil)\n      instrument :upload, key: key, checksum: checksum do\n        begin\n          content_disposition = content_disposition_with(type: disposition, filename: filename) if disposition \u0026amp;\u0026amp; filename\n          bucket.create_file(io, key, md5: checksum, content_type: content_type, content_disposition: content_disposition)\n        rescue Google::Cloud::InvalidArgumentError\n          raise ActiveStorage::IntegrityError\n        end\n      end\n    end\n\n    def update_metadata(key, content_type:, disposition: nil, filename: nil)\n      instrument :update_metadata, key: key, content_type: content_type, disposition: disposition do\n        file_for(key).update do |file|\n          file.content_type = content_type\n          if disposition \u0026amp;\u0026amp; filename\n            file.content_disposition = content_disposition_with(type: disposition, filename: filename)\n          end\n        end\n      end\n    end\n  end\n\n  module StoreMetadata\n    def upload_without_unfurling(io)\n      service.upload key, io, checksum: checksum, **service_metadata\n    end\n\n    def identify\n      unless identified?\n        update! content_type: identify_content_type, identified: true\n        update_service_metadata\n      end\n    end\n\n    private\n      def service_metadata\n        if forcibly_serve_as_binary?\n          { content_type: \u0026quot;application/octet-stream\u0026quot;, disposition: :attachment, filename: filename }\n        else\n          { content_type: content_type }\n        end\n      end\n\n      def update_service_metadata\n        service.update_metadata key, service_metadata if service_metadata.any?\n      end\n  end\nend\n\nRails.application.config.to_prepare do\n  ActiveStorage::Service::GCSService.prepend ActiveStorage::GCSMetadata\n  ActiveStorage::Blob.prepend ActiveStorage::StoreMetadata\nend\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eFor Disk service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003erequire \u0026#39;active_storage\u0026#39;\nrequire \u0026#39;active_storage/service/disk_service\u0026#39;\n\nmodule ActiveStorage\n  module GetParamsFromKey\n    def show\n      if key = decode_verified_key\n        serve_file disk_service.path_for(key[:key]), content_type: key[:content_type], disposition: key[:disposition]\n      else\n        super\n      end\n    rescue Errno::ENOENT\n      head :not_found\n    end\n  end\n\n  module IncludeParamsInKey\n    def upload(key, io, checksum: nil, **)\n      super(key, io, checksum: checksum)\n    end\n\n    def update_metadata(key, **)\n    end\n\n    def url(key, expires_in:, filename:, disposition:, content_type:)\n      instrument :url, key: key do |payload|\n        content_disposition = content_disposition_with(type: disposition, filename: filename)\n        verified_key_with_expiration = ActiveStorage.verifier.generate(\n          {\n            key: key,\n            disposition: content_disposition,\n            content_type: content_type\n          },\n          { expires_in: expires_in,\n          purpose: :blob_key }\n        )\n\n        generated_url = url_helpers.rails_disk_service_url(verified_key_with_expiration,\n          host: current_host,\n          disposition: content_disposition,\n          content_type: content_type,\n          filename: filename\n        )\n        payload[:url] = generated_url\n\n        generated_url\n      end\n    end\n  end\nend\n\nRails.application.config.to_prepare do\n  ActiveStorage::DiskController.prepend ActiveStorage::GetParamsFromKey\n  ActiveStorage::Service::DiskService.prepend ActiveStorage::IncludeParamsInKey\nend\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e"},{"category":"researcher","can_view?":true,"can_create?":false}]}