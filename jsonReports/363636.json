{"id":363636,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8zNjM2MzY=","url":"https://hackerone.com/reports/363636","title":"DoS through PeerExplorer","state":"Closed","substate":"resolved","severity_rating":"high","readable_substate":"Resolved","created_at":"2018-06-09T05:00:54.753Z","submitted_at":"2018-06-09T05:00:54.753Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"z3t","url":"/z3t","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/042/875/f509a2a60ca4f406a7194137e1f5df0ea52cc0c9_original.jpg/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a"},"is_me?":false,"cleared":true,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":25854,"url":"https://hackerone.com/iovlabs","handle":"iovlabs","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/Prz5MCDWRGv5MpRAQsmSVoLw/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/Prz5MCDWRGv5MpRAQsmSVoLw/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"IOVLabs","twitter_handle":"iovlabs","website":"https://www.iovlabs.org/","about":"Building Value Networks"}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":true,"disclosed_at":"2019-09-18T13:16:28.759Z","bug_reporter_agreed_on_going_public_at":null,"team_member_agreed_on_going_public_at":"2019-09-18T13:07:08.066Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"**Summary:** The peer discovery implementation is vulnerable to a Denial of Service attack due to improper management of connections.\n\n**Description:** The two main files of interest in detailing this vulnerability are [PeerExplorer.java](https://github.com/rsksmart/rskj/blob/master/rskj-core/src/main/java/co/rsk/net/discovery/PeerExplorer.java) and [NodeChallengeManager.java](https://github.com/rsksmart/rskj/blob/master/rskj-core/src/main/java/co/rsk/net/discovery/NodeChallengeManager.java). To explain the flow of execution I'll be mentioning two theoretical nodes: an attacker, \"N1\" and a target, \"N2\".\n\nWhen N1 sends an initial \"ping\" message to N2, N2 will reply with a \"pong\" message and a subsequent ping message to continue the handshake. After this, when N1 replies with a pong message, N2 will attempt to add N1 to its structure holding established connections. The relevant code snippets from `PeerExplorer.java` are below:\n```    \npublic void handlePong(String ip, PongPeerMessage message) {\n\tPeerDiscoveryRequest request = this.pendingPingRequests.get(message.getMessageId());\n\n\tif (request != null \u0026\u0026 request.validateMessageResponse(message)) {\n\t\tthis.pendingPingRequests.remove(message.getMessageId());\n\t\tNodeChallenge challenge = this.challengeManager.removeChallenge(message.getMessageId());\n\t\tif (challenge == null) {\n\t\t\tthis.addConnection(message, ip, message.getPort());\n\t\t}\n\t}\n}\n...\nprivate void addConnection(PongPeerMessage message, String ip, int port) {\n\tNode senderNode = new Node(message.getNodeId().getID(), ip, port);\n\tif (!StringUtils.equals(senderNode.getHexId(), this.localNode.getHexId())) {\n\t\tOperationResult result = this.distanceTable.addNode(senderNode);\n\n\t\tif (result.isSuccess()) {\n\t\t\tNodeID senderId = senderNode.getId();\n\t\t\tthis.establishedConnections.put(senderId, senderNode);\n\t\t\tlogger.debug(\"New Peer found ip:[{}] port[{}]\", ip, port);\n\t\t} else {\n\t\t\tthis.challengeManager.startChallenge(result.getAffectedEntry().getNode(), senderNode, this);\n\t\t}\n\t}\n}\n```\nThe `addConnection` method first attempts to add N1 to the `NodeDistanceTable` - a structure designed to hold a limited number of nodes (by default, 4096). If this insertion fails due to the target `NodeDistanceTable` bucket already being full, the attempted connection is instead added to `NodeChallengeManager`. The relevant code snippets from `NodeChallengeManager.java` are below:\n```\npublic NodeChallenge startChallenge(Node challengedNode, Node challenger, PeerExplorer explorer) {\n\tPingPeerMessage pingMessage = explorer.sendPing(challengedNode.getAddress(), 1, challengedNode);\n\tString messageId = pingMessage.getMessageId();\n\tNodeChallenge challenge = new NodeChallenge(challengedNode, challenger, messageId);\n\tactiveChallenges.put(messageId, challenge);\n\treturn challenge;\n}\n\npublic NodeChallenge removeChallenge(String challengeId) {\n\treturn activeChallenges.remove(challengeId);\n}\n```\n\nThrough the `startChallenge` method N2 will send N1 another ping message, adding a \"challenge\" to `activeChallenges` with that new ping message's `messageId`. The issue here is that **the entry is only ever removed from `activeChallenges` if N1 replies with a pong that has the same `messageId` as the new ping message** - as seen in `PeerExplorer.handlePong`. Thus, N1 is able to create an arbitrary number of entries in `activeChallenges` by never sending N2 a pong with the challenge ping's `messageId`.\n\nIt should be noted that there is a slight limitation as to how this could be exploited by a single host. The relevant code snippets from `PeerExplorer.java` are below:\n```\npublic PingPeerMessage sendPing(InetSocketAddress nodeAddress, int attempt, Node node) {\n\tPingPeerMessage nodeMessage = checkPendingPeerToAddress(nodeAddress);\n\n\tif (nodeMessage != null) {\n\t\treturn nodeMessage;\n\t}\n\t....\n}\n...\nprivate PingPeerMessage checkPendingPeerToAddress(InetSocketAddress address) {\n\tfor (PeerDiscoveryRequest req : this.pendingPingRequests.values()) {\n\t\tif (req.getAddress().equals(address)) {\n\t\t\treturn (PingPeerMessage) req.getMessage();\n\t\t}\n\t}\n\n\treturn null;\n}\n\n```\nThe `sendPing` method will only ever actually send a new ping to N1 if there are no pending pings to its `InetSocketAddress` (which is deemed equal if the host and port match) - as seen in `checkPendingPeerToAddress`. However, pending pings have a set expiry time (by default, 30 seconds) and those that have expired are cleared by `PeerExplorerCleaner` at a fixed rate (by default, every 60 seconds). So due to this limitation, with the default configuration settings a single host can only complete 65,535 handshakes (one per port) every minute - imposing a (perhaps unreachable) limit on the time it takes to exhaust the target node's memory. Though this can obviously be circumvented by using multiple hosts to attack a target node. \n\n\nBecause most peer discovery functionality identifies nodes by their `NodeID` and not by host/port, it's trivial to send a flood of requests with unique `NodeID`s to fill `NodeDistanceTable` and subsequently make an unrestricted amount of in-memory insertions into `NodeChallengeManager.activeChallenges`. This is further aided by the fact that `NodeChallengeManager` is never purged, so the request flood does not have to occur within a short period of time. Memory exhaustion will eventually occur as the `NodeChallenge` objects begin taking up a significant amount of memory and are not eligible for garbage collection. This is expected to eventually disable node functionality as individual threads die when they throw `OutOfMemoryError`s, but in my testing it ended up crashing the whole JVM after reaching ~200,000 insertions.\n\n## Steps To Reproduce:\n\nI've attached a PoC program that interfaces with the RSKj library for the sake of simplicity. Due to the PoC program being somewhat inefficient and unreliable, I ended up accelerating the testing process by modifying my testing node's `NodeChallengeManager` to make 10 insertions per valid `startChallenge` call. If you're interested in running the PoC despite those issues, follow these steps:\n  1. Download a copy of the RSKj code\n  2. Move the PoC files into the `co.rsk.net.discovery` package (overwrite `PeerExplorer.java` with my modified version)\n  3. Launch a node for testing - ensure peer discovery is enabled\n  4. Compile and run the PoC from `PeerFlood` - arguments format: `\u003clocal_address\u003e \u003ctarget_address\u003e \u003ctarget_port\u003e \u003cnum_threads\u003e`\n  5. Monitor testing node's logs and stability\n\nIf you're developing your own PoC, you need to simply flood a testing node with connections that use random `NodeID`s, completing a single ping\u003c-\u003epong handshake then immediately disconnecting.\n\n## Mitigation\nThis could be mitigated by implementing expiring challenges that are cleared by `PeerExplorerCleaner`.\n\n## Impact\n\nAn attacker could crash any RSKj node with peer discovery enabled (which it is by default).","vulnerability_information_html":"\u003cp\u003e\u003cstrong\u003eSummary:\u003c/strong\u003e The peer discovery implementation is vulnerable to a Denial of Service attack due to improper management of connections.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e The two main files of interest in detailing this vulnerability are \u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Frsksmart%2Frskj%2Fblob%2Fmaster%2Frskj-core%2Fsrc%2Fmain%2Fjava%2Fco%2Frsk%2Fnet%2Fdiscovery%2FPeerExplorer.java\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ePeerExplorer.java\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e and \u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Frsksmart%2Frskj%2Fblob%2Fmaster%2Frskj-core%2Fsrc%2Fmain%2Fjava%2Fco%2Frsk%2Fnet%2Fdiscovery%2FNodeChallengeManager.java\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eNodeChallengeManager.java\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e. To explain the flow of execution I\u0026#39;ll be mentioning two theoretical nodes: an attacker, \u0026quot;N1\u0026quot; and a target, \u0026quot;N2\u0026quot;.\u003c/p\u003e\n\n\u003cp\u003eWhen N1 sends an initial \u0026quot;ping\u0026quot; message to N2, N2 will reply with a \u0026quot;pong\u0026quot; message and a subsequent ping message to continue the handshake. After this, when N1 replies with a pong message, N2 will attempt to add N1 to its structure holding established connections. The relevant code snippets from \u003ccode\u003ePeerExplorer.java\u003c/code\u003e are below:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003epublic void handlePong(String ip, PongPeerMessage message) {\n    PeerDiscoveryRequest request = this.pendingPingRequests.get(message.getMessageId());\n\n    if (request != null \u0026amp;\u0026amp; request.validateMessageResponse(message)) {\n        this.pendingPingRequests.remove(message.getMessageId());\n        NodeChallenge challenge = this.challengeManager.removeChallenge(message.getMessageId());\n        if (challenge == null) {\n            this.addConnection(message, ip, message.getPort());\n        }\n    }\n}\n...\nprivate void addConnection(PongPeerMessage message, String ip, int port) {\n    Node senderNode = new Node(message.getNodeId().getID(), ip, port);\n    if (!StringUtils.equals(senderNode.getHexId(), this.localNode.getHexId())) {\n        OperationResult result = this.distanceTable.addNode(senderNode);\n\n        if (result.isSuccess()) {\n            NodeID senderId = senderNode.getId();\n            this.establishedConnections.put(senderId, senderNode);\n            logger.debug(\u0026quot;New Peer found ip:[{}] port[{}]\u0026quot;, ip, port);\n        } else {\n            this.challengeManager.startChallenge(result.getAffectedEntry().getNode(), senderNode, this);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003eaddConnection\u003c/code\u003e method first attempts to add N1 to the \u003ccode\u003eNodeDistanceTable\u003c/code\u003e - a structure designed to hold a limited number of nodes (by default, 4096). If this insertion fails due to the target \u003ccode\u003eNodeDistanceTable\u003c/code\u003e bucket already being full, the attempted connection is instead added to \u003ccode\u003eNodeChallengeManager\u003c/code\u003e. The relevant code snippets from \u003ccode\u003eNodeChallengeManager.java\u003c/code\u003e are below:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003epublic NodeChallenge startChallenge(Node challengedNode, Node challenger, PeerExplorer explorer) {\n    PingPeerMessage pingMessage = explorer.sendPing(challengedNode.getAddress(), 1, challengedNode);\n    String messageId = pingMessage.getMessageId();\n    NodeChallenge challenge = new NodeChallenge(challengedNode, challenger, messageId);\n    activeChallenges.put(messageId, challenge);\n    return challenge;\n}\n\npublic NodeChallenge removeChallenge(String challengeId) {\n    return activeChallenges.remove(challengeId);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThrough the \u003ccode\u003estartChallenge\u003c/code\u003e method N2 will send N1 another ping message, adding a \u0026quot;challenge\u0026quot; to \u003ccode\u003eactiveChallenges\u003c/code\u003e with that new ping message\u0026#39;s \u003ccode\u003emessageId\u003c/code\u003e. The issue here is that \u003cstrong\u003ethe entry is only ever removed from \u003ccode\u003eactiveChallenges\u003c/code\u003e if N1 replies with a pong that has the same \u003ccode\u003emessageId\u003c/code\u003e as the new ping message\u003c/strong\u003e - as seen in \u003ccode\u003ePeerExplorer.handlePong\u003c/code\u003e. Thus, N1 is able to create an arbitrary number of entries in \u003ccode\u003eactiveChallenges\u003c/code\u003e by never sending N2 a pong with the challenge ping\u0026#39;s \u003ccode\u003emessageId\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIt should be noted that there is a slight limitation as to how this could be exploited by a single host. The relevant code snippets from \u003ccode\u003ePeerExplorer.java\u003c/code\u003e are below:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003epublic PingPeerMessage sendPing(InetSocketAddress nodeAddress, int attempt, Node node) {\n    PingPeerMessage nodeMessage = checkPendingPeerToAddress(nodeAddress);\n\n    if (nodeMessage != null) {\n        return nodeMessage;\n    }\n    ....\n}\n...\nprivate PingPeerMessage checkPendingPeerToAddress(InetSocketAddress address) {\n    for (PeerDiscoveryRequest req : this.pendingPingRequests.values()) {\n        if (req.getAddress().equals(address)) {\n            return (PingPeerMessage) req.getMessage();\n        }\n    }\n\n    return null;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003esendPing\u003c/code\u003e method will only ever actually send a new ping to N1 if there are no pending pings to its \u003ccode\u003eInetSocketAddress\u003c/code\u003e (which is deemed equal if the host and port match) - as seen in \u003ccode\u003echeckPendingPeerToAddress\u003c/code\u003e. However, pending pings have a set expiry time (by default, 30 seconds) and those that have expired are cleared by \u003ccode\u003ePeerExplorerCleaner\u003c/code\u003e at a fixed rate (by default, every 60 seconds). So due to this limitation, with the default configuration settings a single host can only complete 65,535 handshakes (one per port) every minute - imposing a (perhaps unreachable) limit on the time it takes to exhaust the target node\u0026#39;s memory. Though this can obviously be circumvented by using multiple hosts to attack a target node. \u003c/p\u003e\n\n\u003cp\u003eBecause most peer discovery functionality identifies nodes by their \u003ccode\u003eNodeID\u003c/code\u003e and not by host/port, it\u0026#39;s trivial to send a flood of requests with unique \u003ccode\u003eNodeID\u003c/code\u003es to fill \u003ccode\u003eNodeDistanceTable\u003c/code\u003e and subsequently make an unrestricted amount of in-memory insertions into \u003ccode\u003eNodeChallengeManager.activeChallenges\u003c/code\u003e. This is further aided by the fact that \u003ccode\u003eNodeChallengeManager\u003c/code\u003e is never purged, so the request flood does not have to occur within a short period of time. Memory exhaustion will eventually occur as the \u003ccode\u003eNodeChallenge\u003c/code\u003e objects begin taking up a significant amount of memory and are not eligible for garbage collection. This is expected to eventually disable node functionality as individual threads die when they throw \u003ccode\u003eOutOfMemoryError\u003c/code\u003es, but in my testing it ended up crashing the whole JVM after reaching ~200,000 insertions.\u003c/p\u003e\n\n\u003ch2 id=\"steps-to-reproduce\"\u003eSteps To Reproduce:\u003c/h2\u003e\n\n\u003cp\u003eI\u0026#39;ve attached a PoC program that interfaces with the RSKj library for the sake of simplicity. Due to the PoC program being somewhat inefficient and unreliable, I ended up accelerating the testing process by modifying my testing node\u0026#39;s \u003ccode\u003eNodeChallengeManager\u003c/code\u003e to make 10 insertions per valid \u003ccode\u003estartChallenge\u003c/code\u003e call. If you\u0026#39;re interested in running the PoC despite those issues, follow these steps:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eDownload a copy of the RSKj code\u003c/li\u003e\n\u003cli\u003eMove the PoC files into the \u003ccode\u003eco.rsk.net.discovery\u003c/code\u003e package (overwrite \u003ccode\u003ePeerExplorer.java\u003c/code\u003e with my modified version)\u003c/li\u003e\n\u003cli\u003eLaunch a node for testing - ensure peer discovery is enabled\u003c/li\u003e\n\u003cli\u003eCompile and run the PoC from \u003ccode\u003ePeerFlood\u003c/code\u003e - arguments format: \u003ccode\u003e\u0026lt;local_address\u0026gt; \u0026lt;target_address\u0026gt; \u0026lt;target_port\u0026gt; \u0026lt;num_threads\u0026gt;\u003c/code\u003e\n\u003c/li\u003e\n\u003cli\u003eMonitor testing node\u0026#39;s logs and stability\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eIf you\u0026#39;re developing your own PoC, you need to simply flood a testing node with connections that use random \u003ccode\u003eNodeID\u003c/code\u003es, completing a single ping\u0026lt;-\u0026gt;pong handshake then immediately disconnecting.\u003c/p\u003e\n\n\u003ch2 id=\"mitigation\"\u003eMitigation\u003c/h2\u003e\n\n\u003cp\u003eThis could be mitigated by implementing expiring challenges that are cleared by \u003ccode\u003ePeerExplorerCleaner\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"impact\"\u003eImpact\u003c/h2\u003e\n\n\u003cp\u003eAn attacker could crash any RSKj node with peer discovery enabled (which it is by default).\u003c/p\u003e\n","bounty_amount":"4000.0","formatted_bounty":"$4,000","weakness":{"id":48,"name":"Denial of Service"},"original_report_id":null,"original_report_url":null,"attachments":[{"id":306904,"file_name":"PoC.zip","expiring_url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/306/904/b3bb57dc81076b13db555b631fa4d85b459d15bd/PoC.zip?response-content-disposition=attachment%3B%20filename%3D%22PoC.zip%22%3B%20filename%2A%3DUTF-8%27%27PoC.zip\u0026response-content-type=application%2Fzip\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQY55CA6OQ%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T054401Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJn%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIEcehEzJ6wx5cJVBI4ifSuKdHpXuLtuSHmh8SQmXgyhZAiEAmRgGrwChBEkjjlBm%2FjlBtMcBhRzrhQNXyXI9xj%2BctvcqtAMIUhABGgwwMTM2MTkyNzQ4NDkiDAcHHyX1klaXROO7PiqRAwolqCQb1T1qFrFJAaWyztYE1JDBuzLZ4RwAyeKpcLUT4tyRqOd0dd8i4Q%2Bdjr6CKjIwT4czi1qgG1Zc64xBVWsgift2qy2JjNaoHLTUAc2KLDUNHA0TNoe8bX0oc8a%2FwT8uTFJC95SwDTvxHJ1p0gXKjQzsPS8Pmchr%2B084C8EjUen3Ep0CWQzdO%2FqpzpNi57wg8K7fKdB1QGnYNWoZdB5Oy5EISNv9tG0KxDsBpen93okG220BUzCnopM029Epvj2JEWxnATinRfem%2FweYutcyMAcCkbrgBQ8K8e1gHB5A%2B0u28Q%2FVcP31FhOWgULsAluXkn3GslCMytJCmgqijruu4ZYTEnan%2FWKY5YIAA7lqa3BGrYfkahBrQoqEjUUVdIMtzaJamU8Ar78sCeOuD1pmEl%2BL11bJnsiKfDWlGrVeGbAfhGOY8kc%2Fl0wOCOrTXSudIuxOce8DyfTk8hDaOyvB1s7B5C1EjmMCLhImkKwIX2OwfxK%2BL3R40TJMB8Cpgj1PZYAX4%2FoTvwQ2NE7lqB1NMJ2Eqv8FOusBa2sano2o9LnQ3Zz62xDTky5R5ZhcEoLoUN10wDcNGN%2Bl7jbC3Je6yQISTTUZUnFVUaCZviUohA31W7wKMqcULZ8gdS95RnBq56Jnr5mGBpMl01uOWWwq9VYekx0eqwrKG0fnJZt8nzuga5YXIEEdK00GhGaiOPPln2qn0JVgHc7HAmAbONUCYQPXTsMwDpIiMtxst0E4pt9%2BY%2Bmr5CmKeOg9Cr%2F3ZLSrZYQfcVbd%2BLr3n2r8jmT9zA0weoyT0PAWCkOVSyWi1l2NnOIuIVvfIX4Z6FKNLRAS%2BMDRVCl0b%2Bmn7Qq3MoosKsUkOQ%3D%3D\u0026X-Amz-Signature=32d4115a44daa9a7a95697840e1e3216c2a491184e822e66270062ffa6a3be82","file_size":2341,"type":"application/zip"}],"allow_singular_disclosure_at":null,"vote_count":44,"voters":["lucash-dev","spam404","sameerphad72","s_p_q_r","dhakal_ananda","caesim","theappsec","mygf","cyanpiny","eveeez","and 34 more..."],"severity":{"rating":"high","score":7.7,"author_type":"Team","metrics":{"attack_vector":"network","attack_complexity":"high","privileges_required":"none","user_interaction":"none","scope":"unchanged","confidentiality":"none","integrity":"none","availability":"high"}},"structured_scope":{"databaseId":5820,"asset_type":"SOURCE_CODE","asset_identifier":"https://github.com/rsksmart/rskj","max_severity":"critical"},"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":2862009,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for the clear and detailed report Jacob! \n\nTo make your PoC attack succeed exhausting the program's memory and crashing it you had modified the target RSKj code . It will be helpful for us if you can provide more information to estimate the amount of memory an attacker can force the node to allocate and for how long for each source IP address.\n\nPlease share your modified `NodeChallengeManager`  and details of the target system against which the attack succeeded including CPU, RAM and Java VM memory limits configuration.\n\nThank you","markdown_message":"\u003cp\u003eThanks for the clear and detailed report Jacob! \u003c/p\u003e\n\n\u003cp\u003eTo make your PoC attack succeed exhausting the program\u0026#39;s memory and crashing it you had modified the target RSKj code . It will be helpful for us if you can provide more information to estimate the amount of memory an attacker can force the node to allocate and for how long for each source IP address.\u003c/p\u003e\n\n\u003cp\u003ePlease share your modified \u003ccode\u003eNodeChallengeManager\u003c/code\u003e  and details of the target system against which the attack succeeded including CPU, RAM and Java VM memory limits configuration.\u003c/p\u003e\n\n\u003cp\u003eThank you\u003c/p\u003e\n","automated_response":false,"created_at":"2018-06-09T12:20:03.692Z","updated_at":"2018-06-09T12:20:03.692Z","actor":{"username":"julianor","cleared":false,"url":"/julianor","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"iovlabs","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2863049,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for the quick response!\n\n\u003eIt will be helpful for us if you can provide more information to estimate the amount of memory an attacker can force the node to allocate and for how long for each source IP address.\n\nTo measure the memory usage of `NodeChallengeManager.activeChallenges` I wrote a program (attached as `MemTest.java`) that uses the memory measurement utility [Classmexer](https://www.javamex.com/classmexer/). With this I measured memory usage in increments of 10,000 insertions into a structure identical to `activeChallenges`. The results of that are as follows:\n```\n0 entries = 64 bytes\n10000 entries = 2785848 bytes\n20000 entries = 5571200 bytes\n30000 entries = 8421080 bytes\n40000 entries = 11139592 bytes\n50000 entries = 14122256 bytes\n60000 entries = 16841752 bytes\n70000 entries = 19560104 bytes\n80000 entries = 22278232 bytes\n90000 entries = 24996520 bytes\n100000 entries = 28239416 bytes\n```\nThe memory usage of each increment remains pretty consistent with each additional 10,000 entries occupying ~2.8MB of memory and 100,000 entries occupying ~28MB. Given these measurements and the limitation I mentioned in the initial report, with the default configuration a single host can theoretically force a maximum of ~18.2MB in allocations per minute.\n\nAs stated before, entries in `activeChallenges` are never removed unless a specific \"pong\" message is received, making the entries ineligible for garbage collection and thus resulting in the allocations remaining until the JVM shuts down.\n\n\u003ePlease share your modified NodeChallengeManager and details of the target system against which the attack succeeded including CPU, RAM and Java VM memory limits configuration.\n\nI've attached my modified `NodeChallengeManager.java` that I initially used to accelerate the PoC, but in my latest test I was able to trigger a crash without the modifications. Unfortunately I don't have the hardware resources to run a full test against a node running with the [recommended system specs](https://github.com/rsksmart/rskj/wiki/Node-Minimum-Requirements). However, because the allocated memory in the attack is never freed, a crash should be reachable regardless of system specs. My latest testing was against a node running on a 2GB RAM Debian server, the relevant JVM memory configurations for it are below:\n```    \nuintx InitialHeapSize                          := 33554432\nuintx MaxHeapSize                              := 526385152\n```\n","markdown_message":"\u003cp\u003eThanks for the quick response!\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eIt will be helpful for us if you can provide more information to estimate the amount of memory an attacker can force the node to allocate and for how long for each source IP address.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eTo measure the memory usage of \u003ccode\u003eNodeChallengeManager.activeChallenges\u003c/code\u003e I wrote a program (attached as \u003ccode\u003eMemTest.java\u003c/code\u003e) that uses the memory measurement utility \u003ca href=\"/redirect?url=https%3A%2F%2Fwww.javamex.com%2Fclassmexer%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003eClassmexer\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e. With this I measured memory usage in increments of 10,000 insertions into a structure identical to \u003ccode\u003eactiveChallenges\u003c/code\u003e. The results of that are as follows:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003e0 entries = 64 bytes\n10000 entries = 2785848 bytes\n20000 entries = 5571200 bytes\n30000 entries = 8421080 bytes\n40000 entries = 11139592 bytes\n50000 entries = 14122256 bytes\n60000 entries = 16841752 bytes\n70000 entries = 19560104 bytes\n80000 entries = 22278232 bytes\n90000 entries = 24996520 bytes\n100000 entries = 28239416 bytes\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe memory usage of each increment remains pretty consistent with each additional 10,000 entries occupying ~2.8MB of memory and 100,000 entries occupying ~28MB. Given these measurements and the limitation I mentioned in the initial report, with the default configuration a single host can theoretically force a maximum of ~18.2MB in allocations per minute.\u003c/p\u003e\n\n\u003cp\u003eAs stated before, entries in \u003ccode\u003eactiveChallenges\u003c/code\u003e are never removed unless a specific \u0026quot;pong\u0026quot; message is received, making the entries ineligible for garbage collection and thus resulting in the allocations remaining until the JVM shuts down.\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003ePlease share your modified NodeChallengeManager and details of the target system against which the attack succeeded including CPU, RAM and Java VM memory limits configuration.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eI\u0026#39;ve attached my modified \u003ccode\u003eNodeChallengeManager.java\u003c/code\u003e that I initially used to accelerate the PoC, but in my latest test I was able to trigger a crash without the modifications. Unfortunately I don\u0026#39;t have the hardware resources to run a full test against a node running with the \u003ca href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Frsksmart%2Frskj%2Fwiki%2FNode-Minimum-Requirements\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003erecommended system specs\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e. However, because the allocated memory in the attack is never freed, a crash should be reachable regardless of system specs. My latest testing was against a node running on a 2GB RAM Debian server, the relevant JVM memory configurations for it are below:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003euintx InitialHeapSize                          := 33554432\nuintx MaxHeapSize                              := 526385152\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2018-06-10T06:58:17.666Z","updated_at":"2018-06-10T06:58:17.666Z","actor":{"username":"z3t","cleared":true,"url":"/z3t","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/042/875/f509a2a60ca4f406a7194137e1f5df0ea52cc0c9_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"attachments":[{"id":307277,"filename":"NodeChallengeManager.java","type":"text/plain","url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/307/277/4e38349faa8901e186a3b41ec681bb5e44bdff99/NodeChallengeManager.java?response-content-disposition=attachment%3B%20filename%3D%22NodeChallengeManager.java%22%3B%20filename%2A%3DUTF-8%27%27NodeChallengeManager.java\u0026response-content-type=text%2Fplain\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQY55CA6OQ%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T054401Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJn%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIEcehEzJ6wx5cJVBI4ifSuKdHpXuLtuSHmh8SQmXgyhZAiEAmRgGrwChBEkjjlBm%2FjlBtMcBhRzrhQNXyXI9xj%2BctvcqtAMIUhABGgwwMTM2MTkyNzQ4NDkiDAcHHyX1klaXROO7PiqRAwolqCQb1T1qFrFJAaWyztYE1JDBuzLZ4RwAyeKpcLUT4tyRqOd0dd8i4Q%2Bdjr6CKjIwT4czi1qgG1Zc64xBVWsgift2qy2JjNaoHLTUAc2KLDUNHA0TNoe8bX0oc8a%2FwT8uTFJC95SwDTvxHJ1p0gXKjQzsPS8Pmchr%2B084C8EjUen3Ep0CWQzdO%2FqpzpNi57wg8K7fKdB1QGnYNWoZdB5Oy5EISNv9tG0KxDsBpen93okG220BUzCnopM029Epvj2JEWxnATinRfem%2FweYutcyMAcCkbrgBQ8K8e1gHB5A%2B0u28Q%2FVcP31FhOWgULsAluXkn3GslCMytJCmgqijruu4ZYTEnan%2FWKY5YIAA7lqa3BGrYfkahBrQoqEjUUVdIMtzaJamU8Ar78sCeOuD1pmEl%2BL11bJnsiKfDWlGrVeGbAfhGOY8kc%2Fl0wOCOrTXSudIuxOce8DyfTk8hDaOyvB1s7B5C1EjmMCLhImkKwIX2OwfxK%2BL3R40TJMB8Cpgj1PZYAX4%2FoTvwQ2NE7lqB1NMJ2Eqv8FOusBa2sano2o9LnQ3Zz62xDTky5R5ZhcEoLoUN10wDcNGN%2Bl7jbC3Je6yQISTTUZUnFVUaCZviUohA31W7wKMqcULZ8gdS95RnBq56Jnr5mGBpMl01uOWWwq9VYekx0eqwrKG0fnJZt8nzuga5YXIEEdK00GhGaiOPPln2qn0JVgHc7HAmAbONUCYQPXTsMwDpIiMtxst0E4pt9%2BY%2Bmr5CmKeOg9Cr%2F3ZLSrZYQfcVbd%2BLr3n2r8jmT9zA0weoyT0PAWCkOVSyWi1l2NnOIuIVvfIX4Z6FKNLRAS%2BMDRVCl0b%2Bmn7Qq3MoosKsUkOQ%3D%3D\u0026X-Amz-Signature=7c91f010dc7ebfa5488bf65fda28cdc3a615d329f1b30fe76c0d14e113aa589e"},{"id":307258,"filename":"MemTest.java","type":"text/x-c","url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/307/258/f0bd4ed11a989514c37088069a22ef52bc14671a/MemTest.java?response-content-disposition=attachment%3B%20filename%3D%22MemTest.java%22%3B%20filename%2A%3DUTF-8%27%27MemTest.java\u0026response-content-type=text%2Fx-c\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQY55CA6OQ%2F20201229%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20201229T054401Z\u0026X-Amz-Expires=3600\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJn%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIEcehEzJ6wx5cJVBI4ifSuKdHpXuLtuSHmh8SQmXgyhZAiEAmRgGrwChBEkjjlBm%2FjlBtMcBhRzrhQNXyXI9xj%2BctvcqtAMIUhABGgwwMTM2MTkyNzQ4NDkiDAcHHyX1klaXROO7PiqRAwolqCQb1T1qFrFJAaWyztYE1JDBuzLZ4RwAyeKpcLUT4tyRqOd0dd8i4Q%2Bdjr6CKjIwT4czi1qgG1Zc64xBVWsgift2qy2JjNaoHLTUAc2KLDUNHA0TNoe8bX0oc8a%2FwT8uTFJC95SwDTvxHJ1p0gXKjQzsPS8Pmchr%2B084C8EjUen3Ep0CWQzdO%2FqpzpNi57wg8K7fKdB1QGnYNWoZdB5Oy5EISNv9tG0KxDsBpen93okG220BUzCnopM029Epvj2JEWxnATinRfem%2FweYutcyMAcCkbrgBQ8K8e1gHB5A%2B0u28Q%2FVcP31FhOWgULsAluXkn3GslCMytJCmgqijruu4ZYTEnan%2FWKY5YIAA7lqa3BGrYfkahBrQoqEjUUVdIMtzaJamU8Ar78sCeOuD1pmEl%2BL11bJnsiKfDWlGrVeGbAfhGOY8kc%2Fl0wOCOrTXSudIuxOce8DyfTk8hDaOyvB1s7B5C1EjmMCLhImkKwIX2OwfxK%2BL3R40TJMB8Cpgj1PZYAX4%2FoTvwQ2NE7lqB1NMJ2Eqv8FOusBa2sano2o9LnQ3Zz62xDTky5R5ZhcEoLoUN10wDcNGN%2Bl7jbC3Je6yQISTTUZUnFVUaCZviUohA31W7wKMqcULZ8gdS95RnBq56Jnr5mGBpMl01uOWWwq9VYekx0eqwrKG0fnJZt8nzuga5YXIEEdK00GhGaiOPPln2qn0JVgHc7HAmAbONUCYQPXTsMwDpIiMtxst0E4pt9%2BY%2Bmr5CmKeOg9Cr%2F3ZLSrZYQfcVbd%2BLr3n2r8jmT9zA0weoyT0PAWCkOVSyWi1l2NnOIuIVvfIX4Z6FKNLRAS%2BMDRVCl0b%2Bmn7Qq3MoosKsUkOQ%3D%3D\u0026X-Amz-Signature=ada4ed3df14f49d8cdf5845713c87e6e3538f2ed6158f9728d7ae2a3d4986908"}],"genius_execution_id":null,"team_handle":"iovlabs","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2869308,"is_internal":false,"editable":false,"type":"Activities::ReportSeverityUpdated","message":"","markdown_message":"","automated_response":false,"created_at":"2018-06-11T18:27:09.648Z","updated_at":"2018-06-11T18:27:09.648Z","additional_data":{"old_severity":"High (7.1)","new_severity":"High (7.7)","old_severity_id":165536,"new_severity_id":166366},"actor":{"username":"julianor","cleared":false,"url":"/julianor","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"iovlabs","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2869329,"is_internal":false,"editable":false,"type":"Activities::BugTriaged","message":"We were not able to reproduce your \"crashing the whole JVM\" result but the missing removal of challenges from `NodeChallengeManager.activeChallenges` after a timeout is being fixed.","markdown_message":"\u003cp\u003eWe were not able to reproduce your \u0026quot;crashing the whole JVM\u0026quot; result but the missing removal of challenges from \u003ccode\u003eNodeChallengeManager.activeChallenges\u003c/code\u003e after a timeout is being fixed.\u003c/p\u003e\n","automated_response":false,"created_at":"2018-06-11T18:37:13.123Z","updated_at":"2018-06-11T18:37:13.123Z","actor":{"username":"julianor","cleared":false,"url":"/julianor","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"iovlabs","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2869351,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for the update. Just to add a clarification, I discovered that the full JVM crashes were due to the JVM not being able to reach its `MaxHeapSize` on the low-memory VM I initially used for testing. In subsequent tests the expected behavior of most threads crashing with `OutOfMemoryError`s was observed.","markdown_message":"\u003cp\u003eThanks for the update. Just to add a clarification, I discovered that the full JVM crashes were due to the JVM not being able to reach its \u003ccode\u003eMaxHeapSize\u003c/code\u003e on the low-memory VM I initially used for testing. In subsequent tests the expected behavior of most threads crashing with \u003ccode\u003eOutOfMemoryError\u003c/code\u003es was observed.\u003c/p\u003e\n","automated_response":false,"created_at":"2018-06-11T18:45:03.111Z","updated_at":"2018-06-11T18:45:03.111Z","actor":{"username":"z3t","cleared":true,"url":"/z3t","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/042/875/f509a2a60ca4f406a7194137e1f5df0ea52cc0c9_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"iovlabs","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2874980,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hello Jacob,  \n\nWe would be grateful if you could review the fix pushed to the `update_explorer` branch and share your comments here.\n\nhttps://github.com/rsksmart/rskj/commits/update_explorer \n\nThank you!","markdown_message":"\u003cp\u003eHello Jacob,  \u003c/p\u003e\n\n\u003cp\u003eWe would be grateful if you could review the fix pushed to the \u003ccode\u003eupdate_explorer\u003c/code\u003e branch and share your comments here.\u003c/p\u003e\n\n\u003cp\u003e\u003ca title=\"https://github.com/rsksmart/rskj/commits/update_explorer\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Frsksmart%2Frskj%2Fcommits%2Fupdate_explorer\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/rsksmart/rskj/commits/update_explorer\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003eThank you!\u003c/p\u003e\n","automated_response":false,"created_at":"2018-06-12T19:00:34.179Z","updated_at":"2018-06-12T19:00:34.179Z","actor":{"username":"julianor","cleared":false,"url":"/julianor","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"iovlabs","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2875398,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"I've reviewed the changes and the issue appears to be fixed.","markdown_message":"\u003cp\u003eI\u0026#39;ve reviewed the changes and the issue appears to be fixed.\u003c/p\u003e\n","automated_response":false,"created_at":"2018-06-12T21:20:40.719Z","updated_at":"2018-06-12T21:20:40.719Z","actor":{"username":"z3t","cleared":true,"url":"/z3t","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/042/875/f509a2a60ca4f406a7194137e1f5df0ea52cc0c9_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"iovlabs","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2880830,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"Thank you very much for the time spent and the clear report, we really appreciate your hard work! We look forward to hearing more from you! Are you ok if we make this report public?","markdown_message":"\u003cp\u003eThank you very much for the time spent and the clear report, we really appreciate your hard work! We look forward to hearing more from you! Are you ok if we make this report public?\u003c/p\u003e\n","automated_response":false,"created_at":"2018-06-13T20:15:47.588Z","updated_at":"2018-06-13T20:15:47.588Z","actor":{"url":"/iovlabs","ibb":false,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/Prz5MCDWRGv5MpRAQsmSVoLw/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"IOVLabs"}},"bounty_amount":"4000.0","bounty_currency":"usd","bonus_amount":"0.0","genius_execution_id":null,"team_handle":"iovlabs","collaborator":{"username":"z3t","url":"/z3t"},"actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2880950,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"","markdown_message":"","automated_response":false,"created_at":"2018-06-13T20:54:19.732Z","updated_at":"2018-06-13T20:54:19.732Z","actor":{"username":"julianor","cleared":false,"url":"/julianor","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"reporter":{"username":"z3t","url":"/z3t"},"genius_execution_id":null,"team_handle":"iovlabs","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2880963,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Awesome, thank you so much for the bounty and quick fix! I'm fine with making this report public, but we should probably define some period of delay so users have time to update as needed.","markdown_message":"\u003cp\u003eAwesome, thank you so much for the bounty and quick fix! I\u0026#39;m fine with making this report public, but we should probably define some period of delay so users have time to update as needed.\u003c/p\u003e\n","automated_response":false,"created_at":"2018-06-13T21:01:56.309Z","updated_at":"2018-06-13T21:01:56.309Z","actor":{"username":"z3t","cleared":true,"url":"/z3t","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/042/875/f509a2a60ca4f406a7194137e1f5df0ea52cc0c9_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"iovlabs","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":5835118,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2019-09-18T13:07:08.095Z","updated_at":"2019-09-18T13:07:08.095Z","first_to_agree":true,"actor":{"username":"bernacodesido","cleared":false,"url":"/bernacodesido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/663/587/40cf6f2372b7222ff24e3ec497dc994f5b9dca4c_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"iovlabs","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":5835190,"is_internal":false,"editable":false,"type":"Activities::ManuallyDisclosed","message":"","markdown_message":"","automated_response":false,"created_at":"2019-09-18T13:16:28.666Z","updated_at":"2019-09-18T13:16:28.666Z","actor":{"username":"julianor","cleared":false,"url":"/julianor","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"iovlabs","actor_is_team_member":true,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}