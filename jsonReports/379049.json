{"id":379049,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8zNzkwNDk=","url":"https://hackerone.com/reports/379049","title":"Attcker can trick monero wallet into reporting it recived twice as much with alternative tx_keypubs","state":"Closed","substate":"resolved","severity_rating":"high","readable_substate":"Resolved","created_at":"2018-07-08T00:06:19.804Z","submitted_at":"2018-07-08T00:06:19.804Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"phiren","url":"/phiren","profile_picture_urls":{"small":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":7731,"url":"https://hackerone.com/monero","handle":"monero","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":false,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Monero","twitter_handle":"monero","website":"https://getmonero.org","about":" Monero: the secure, private, untraceable cryptocurrency"}},"has_bounty?":false,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2018-07-27T21:28:34.494Z","bug_reporter_agreed_on_going_public_at":"2018-07-27T21:28:34.387Z","team_member_agreed_on_going_public_at":"2018-07-27T10:19:44.809Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"**Summary:** multiple identical  tx_pub_keys were patched, but you can still use alternative tx_pub_keys to get the same result.\n\n**Description:** An attacker can craft an XMR transaction which causes the receiving wallet to report that it received twice as much XMR as the attacker actually sent.\n\nThe balance of the wallet isn't effected, so a personal user probably won't be ticked, however the doubled amount is reported over the get_transfers RPC call.\n\nThis is especially devastating for automated wallets, such as cryptocurrency exchanges that rely on RPC calls returning the correct result. \n\nThis attack is a slight modification of the previous flaw that was patched in pull request 3985. That flaw allows unlimited multiplication of funds, instead of just a 2x multiplication that this attack allows.\n\nThis attack leverages the alternative tx_pub_keys feature introduced with subaddresses. extra data is arranged so it contains:\n\n1. A dummy tx_pub_key\n2. An array of alternative tx_pub_keys entries all containing the legitimate txkey for each output.\n3. The legitimate tx_pub_key\n\nThe process_new_transaction function will:\n\n1. Grab the dummy tx_pub_key\n2. Grab the array of alternative tx_pub_keys\n3. Scan all the outputs with both the dummy and alternative tx_pub_keys. Which will match on the legitimate tx_pub_keys.\n4. Loop back to the start, grab the legitimate tx_pub_key\n5. Since the alternative keys were not added into the public_keys_seen set, it scans all the outputs again.\n6. Hacked.\n \n## Releases Affected:\n\n * Monero master ebf2818ab5f42b10745cb99d07920f3197c3d914\n * Monero 0.12.3.0 release tag\n * Probably any Monero release since subaddresses were introduced\n\n## Steps To Reproduce:\n\n  1. On the attacking wallet, Patch cryptonote_tx_utils.cpp\n```\n    diff --git a/src/cryptonote_core/cryptonote_tx_utils.cpp b/src/cryptonote_core/cryptonote_tx_utils.cpp\n    index 071ce591..3835690a 100644\n    --- a/src/cryptonote_core/cryptonote_tx_utils.cpp\n    +++ b/src/cryptonote_core/cryptonote_tx_utils.cpp\n    @@ -351,9 +351,15 @@ namespace cryptonote\n           txkey_pub = rct::rct2pk(hwdev.scalarmultBase(rct::sk2rct(tx_key)));\n         }\n         remove_field_from_tx_extra(tx.extra, typeid(tx_extra_pub_key));\n    -    add_tx_pub_key_to_extra(tx, txkey_pub);\n    +    crypto::public_key dummy_key;\n    +    add_tx_pub_key_to_extra(tx, dummy_key);\n    \n         std::vector\u003ccrypto::public_key\u003e additional_tx_public_keys;\n    +    for (size_t i = 0; i \u003c destinations.size(); i++)\n    +      additional_tx_public_keys.push_back(txkey_pub); // One for each output.\n    +\n    +    add_additional_tx_pub_keys_to_extra(tx.extra, additional_tx_public_keys);\n    +    add_tx_pub_key_to_extra(tx, txkey_pub);\n    \n         // we don't need to include additional tx keys if:\n         //   - all the destinations are standard addresses\n    @@ -421,9 +427,9 @@ namespace cryptonote\n           output_index++;\n           summary_outs_money += dst_entr.amount;\n         }\n    -    CHECK_AND_ASSERT_MES(additional_tx_public_keys.size() == additional_tx_keys.size(), false, \"Internal error creating additional public keys\");\n    +    //CHECK_AND_ASSERT_MES(additional_tx_public_keys.size() == additional_tx_keys.size(), false, \"Internal error creating additional public keys\");\n    \n    -    remove_field_from_tx_extra(tx.extra, typeid(tx_extra_additional_pub_keys));\n    +    //remove_field_from_tx_extra(tx.extra, typeid(tx_extra_additional_pub_keys));\n    \n         LOG_PRINT_L2(\"tx pubkey: \" \u003c\u003c txkey_pub);\n         if (need_additional_txkeys)\n\n  2\\. Compile wallet\n  3\\. Do a regular transfer to an exchange wallet.\n  4\\. Profit.\n\n## Impact\n\nBy depositing and withdrawing the same coins, doubling each time; The attacker could eventually steal all XMR from an exchange hotwallet.","vulnerability_information_html":"\u003cp\u003e\u003cstrong\u003eSummary:\u003c/strong\u003e multiple identical  tx_pub_keys were patched, but you can still use alternative tx_pub_keys to get the same result.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e An attacker can craft an XMR transaction which causes the receiving wallet to report that it received twice as much XMR as the attacker actually sent.\u003c/p\u003e\n\n\u003cp\u003eThe balance of the wallet isn\u0026#39;t effected, so a personal user probably won\u0026#39;t be ticked, however the doubled amount is reported over the get_transfers RPC call.\u003c/p\u003e\n\n\u003cp\u003eThis is especially devastating for automated wallets, such as cryptocurrency exchanges that rely on RPC calls returning the correct result. \u003c/p\u003e\n\n\u003cp\u003eThis attack is a slight modification of the previous flaw that was patched in pull request 3985. That flaw allows unlimited multiplication of funds, instead of just a 2x multiplication that this attack allows.\u003c/p\u003e\n\n\u003cp\u003eThis attack leverages the alternative tx_pub_keys feature introduced with subaddresses. extra data is arranged so it contains:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eA dummy tx_pub_key\u003c/li\u003e\n\u003cli\u003eAn array of alternative tx_pub_keys entries all containing the legitimate txkey for each output.\u003c/li\u003e\n\u003cli\u003eThe legitimate tx_pub_key\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThe process_new_transaction function will:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eGrab the dummy tx_pub_key\u003c/li\u003e\n\u003cli\u003eGrab the array of alternative tx_pub_keys\u003c/li\u003e\n\u003cli\u003eScan all the outputs with both the dummy and alternative tx_pub_keys. Which will match on the legitimate tx_pub_keys.\u003c/li\u003e\n\u003cli\u003eLoop back to the start, grab the legitimate tx_pub_key\u003c/li\u003e\n\u003cli\u003eSince the alternative keys were not added into the public_keys_seen set, it scans all the outputs again.\u003c/li\u003e\n\u003cli\u003eHacked.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"releases-affected\"\u003eReleases Affected:\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003eMonero master ebf2818ab5f42b10745cb99d07920f3197c3d914\u003c/li\u003e\n\u003cli\u003eMonero 0.12.3.0 release tag\u003c/li\u003e\n\u003cli\u003eProbably any Monero release since subaddresses were introduced\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"steps-to-reproduce\"\u003eSteps To Reproduce:\u003c/h2\u003e\n\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eOn the attacking wallet, Patch cryptonote_tx_utils.cpp\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e\u003cspan class=\"gh\"\u003ediff --git a/src/cryptonote_core/cryptonote_tx_utils.cpp b/src/cryptonote_core/cryptonote_tx_utils.cpp\nindex 071ce591..3835690a 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/src/cryptonote_core/cryptonote_tx_utils.cpp\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/src/cryptonote_core/cryptonote_tx_utils.cpp\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -351,9 +351,15 @@\u003c/span\u003e namespace cryptonote\n       txkey_pub = rct::rct2pk(hwdev.scalarmultBase(rct::sk2rct(tx_key)));\n     }\n     remove_field_from_tx_extra(tx.extra, typeid(tx_extra_pub_key));\n\u003cspan class=\"gd\"\u003e-    add_tx_pub_key_to_extra(tx, txkey_pub);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+    crypto::public_key dummy_key;\n+    add_tx_pub_key_to_extra(tx, dummy_key);\n\u003c/span\u003e\n     std::vector\u0026lt;crypto::public_key\u0026gt; additional_tx_public_keys;\n\u003cspan class=\"gi\"\u003e+    for (size_t i = 0; i \u0026lt; destinations.size(); i++)\n+      additional_tx_public_keys.push_back(txkey_pub); // One for each output.\n+\n+    add_additional_tx_pub_keys_to_extra(tx.extra, additional_tx_public_keys);\n+    add_tx_pub_key_to_extra(tx, txkey_pub);\n\u003c/span\u003e\n     // we don\u0026#39;t need to include additional tx keys if:\n     //   - all the destinations are standard addresses\n\u003cspan class=\"p\"\u003e@@ -421,9 +427,9 @@\u003c/span\u003e namespace cryptonote\n       output_index++;\n       summary_outs_money += dst_entr.amount;\n     }\n\u003cspan class=\"gd\"\u003e-    CHECK_AND_ASSERT_MES(additional_tx_public_keys.size() == additional_tx_keys.size(), false, \u0026quot;Internal error creating additional public keys\u0026quot;);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+    //CHECK_AND_ASSERT_MES(additional_tx_public_keys.size() == additional_tx_keys.size(), false, \u0026quot;Internal error creating additional public keys\u0026quot;);\n\u003c/span\u003e\n-    remove_field_from_tx_extra(tx.extra, typeid(tx_extra_additional_pub_keys));\n\u003cspan class=\"gi\"\u003e+    //remove_field_from_tx_extra(tx.extra, typeid(tx_extra_additional_pub_keys));\n\u003c/span\u003e\n     LOG_PRINT_L2(\u0026quot;tx pubkey: \u0026quot; \u0026lt;\u0026lt; txkey_pub);\n     if (need_additional_txkeys)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e2. Compile wallet\u003cbr\u003e\n  3. Do a regular transfer to an exchange wallet.\u003cbr\u003e\n  4. Profit.\u003c/p\u003e\n\n\u003ch2 id=\"impact\"\u003eImpact\u003c/h2\u003e\n\n\u003cp\u003eBy depositing and withdrawing the same coins, doubling each time; The attacker could eventually steal all XMR from an exchange hotwallet.\u003c/p\u003e\n","weakness":{"id":65,"name":"Business Logic Errors"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2018-08-26T10:19:44.929Z","allow_singular_disclosure_after":-73942005.8299114,"singular_disclosure_allowed":true,"vote_count":15,"voters":["muon4","spam404","leetboi","dudez","eveeez","apapedulimu","an0nym0us","khizer47","cryptographer","jrballi","and 5 more..."],"severity":{"rating":"high","score":8.2,"author_type":"User","metrics":{"attack_vector":"network","attack_complexity":"low","privileges_required":"none","user_interaction":"none","scope":"unchanged","confidentiality":"none","integrity":"low","availability":"high"}},"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":3013164,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hrm. This was supposed to be fixed by only using those on the first loop.\nThanks for the report, will fix now.\n","markdown_message":"\u003cp\u003eHrm. This was supposed to be fixed by only using those on the first loop.\u003cbr\u003e\nThanks for the report, will fix now.\u003c/p\u003e\n","automated_response":false,"created_at":"2018-07-08T09:25:10.562Z","updated_at":"2018-07-08T09:25:10.562Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3013190,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"The following patch fixes the issue you reported. Thanks for the detailed report.\n```\ndiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex df7ea75..ccf764c 100644\n--- a/src/wallet/wallet2.cpp\n+++ b/src/wallet/wallet2.cpp\n@@ -1238,7 +1238,7 @@ void wallet2::process_new_transaction(const crypto::hash \u0026txid, const cryptonote\n \n     if (public_keys_seen.find(pub_key_field.pub_key) != public_keys_seen.end())\n     {\n-      MWARNING(\"The same transaction pubkey is present more than once, ignoring extra instance\");\n+      MWARNING(\"The same transaction pubkey is present more than once in \" \u003c\u003c txid \u003c\u003c \", ignoring extra instance\");\n       continue;\n     }\n     public_keys_seen.insert(pub_key_field.pub_key);\n@@ -1274,6 +1274,12 @@ void wallet2::process_new_transaction(const crypto::hash \u0026txid, const cryptonote\n         {\n           for (size_t i = 0; i \u003c additional_tx_pub_keys.data.size(); ++i)\n           {\n+            if (public_keys_seen.find(additional_tx_pub_keys.data[i]) != public_keys_seen.end())\n+            {\n+              MWARNING(\"The same transaction extra pubkey is present more than once in \" \u003c\u003c txid \u003c\u003c \", ignoring extra instance\");\n+              continue;\n+            }\n+            public_keys_seen.insert(additional_tx_pub_keys.data[i]);\n             additional_derivations.push_back({});\n             if (!hwdev.generate_key_derivation(additional_tx_pub_keys.data[i], keys.m_view_secret_key, additional_derivations.back()))\n             {\n@@ -1294,6 +1300,12 @@ void wallet2::process_new_transaction(const crypto::hash \u0026txid, const cryptonote\n       {\n         for (size_t n = 0; n \u003c tx_cache_data.additional.size(); ++n)\n         {\n+          if (public_keys_seen.find(tx_cache_data.additional[n].pkey) != public_keys_seen.end())\n+          {\n+            MWARNING(\"The same transaction extra pubkey is present more than once in \" \u003c\u003c txid \u003c\u003c \", ignoring extra instance\");\n+            continue;\n+          }\n+          public_keys_seen.insert(tx_cache_data.additional[n].pkey);\n           additional_tx_pub_keys.data.push_back(tx_cache_data.additional[n].pkey);\n           additional_derivations.push_back(tx_cache_data.additional[n].derivation);\n\n```","markdown_message":"\u003cp\u003eThe following patch fixes the issue you reported. Thanks for the detailed report.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e\u003cspan class=\"gh\"\u003ediff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex df7ea75..ccf764c 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/src/wallet/wallet2.cpp\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/src/wallet/wallet2.cpp\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -1238,7 +1238,7 @@\u003c/span\u003e void wallet2::process_new_transaction(const crypto::hash \u0026amp;txid, const cryptonote\n\n     if (public_keys_seen.find(pub_key_field.pub_key) != public_keys_seen.end())\n     {\n\u003cspan class=\"gd\"\u003e-      MWARNING(\u0026quot;The same transaction pubkey is present more than once, ignoring extra instance\u0026quot;);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+      MWARNING(\u0026quot;The same transaction pubkey is present more than once in \u0026quot; \u0026lt;\u0026lt; txid \u0026lt;\u0026lt; \u0026quot;, ignoring extra instance\u0026quot;);\n\u003c/span\u003e       continue;\n     }\n     public_keys_seen.insert(pub_key_field.pub_key);\n\u003cspan class=\"p\"\u003e@@ -1274,6 +1274,12 @@\u003c/span\u003e void wallet2::process_new_transaction(const crypto::hash \u0026amp;txid, const cryptonote\n         {\n           for (size_t i = 0; i \u0026lt; additional_tx_pub_keys.data.size(); ++i)\n           {\n\u003cspan class=\"gi\"\u003e+            if (public_keys_seen.find(additional_tx_pub_keys.data[i]) != public_keys_seen.end())\n+            {\n+              MWARNING(\u0026quot;The same transaction extra pubkey is present more than once in \u0026quot; \u0026lt;\u0026lt; txid \u0026lt;\u0026lt; \u0026quot;, ignoring extra instance\u0026quot;);\n+              continue;\n+            }\n+            public_keys_seen.insert(additional_tx_pub_keys.data[i]);\n\u003c/span\u003e             additional_derivations.push_back({});\n             if (!hwdev.generate_key_derivation(additional_tx_pub_keys.data[i], keys.m_view_secret_key, additional_derivations.back()))\n             {\n\u003cspan class=\"p\"\u003e@@ -1294,6 +1300,12 @@\u003c/span\u003e void wallet2::process_new_transaction(const crypto::hash \u0026amp;txid, const cryptonote\n       {\n         for (size_t n = 0; n \u0026lt; tx_cache_data.additional.size(); ++n)\n         {\n\u003cspan class=\"gi\"\u003e+          if (public_keys_seen.find(tx_cache_data.additional[n].pkey) != public_keys_seen.end())\n+          {\n+            MWARNING(\u0026quot;The same transaction extra pubkey is present more than once in \u0026quot; \u0026lt;\u0026lt; txid \u0026lt;\u0026lt; \u0026quot;, ignoring extra instance\u0026quot;);\n+            continue;\n+          }\n+          public_keys_seen.insert(tx_cache_data.additional[n].pkey);\n\u003c/span\u003e           additional_tx_pub_keys.data.push_back(tx_cache_data.additional[n].pkey);\n           additional_derivations.push_back(tx_cache_data.additional[n].derivation);\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2018-07-08T09:57:07.366Z","updated_at":"2018-07-08T09:57:31.615Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3013198,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"That patch won't work if multiple outputs are sent to the same subaddress. Each public key lines up with an output and sending multiple outputs to the same address will require repeats in the additional array. \n\nI'm not sure if this happens in practice. ","markdown_message":"\u003cp\u003eThat patch won\u0026#39;t work if multiple outputs are sent to the same subaddress. Each public key lines up with an output and sending multiple outputs to the same address will require repeats in the additional array. \u003c/p\u003e\n\n\u003cp\u003eI\u0026#39;m not sure if this happens in practice. \u003c/p\u003e\n","automated_response":false,"created_at":"2018-07-08T10:05:18.082Z","updated_at":"2018-07-08T10:05:18.082Z","actor":{"username":"phiren","cleared":false,"url":"/phiren","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":3013428,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Better patch after discussion with the reporter:\n```\ncommit 58f28cadf8318d7a0e0e8fd85f257acfef34f62e\nAuthor: moneromooo-monero \u003cmoneromooo-monero@users.noreply.github.com\u003e\nDate:   Sun Jul 8 11:01:13 2018 +0100\n\n    wallet2: ensure outputs are processed only once\n    \n    This should be proof against any way one might get to multiple\n    processing, such as generating the same derivation from the\n    same pubkey, etc\n\ndiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex 4477b97..2de92a5 100644\n--- a/src/wallet/wallet2.cpp\n+++ b/src/wallet/wallet2.cpp\n@@ -1030,6 +1030,16 @@ void wallet2::check_acc_out_precomp(const tx_out \u0026o, const crypto::key_derivatio\n   tx_scan_info.error = false;\n }\n //----------------------------------------------------------------------------------------------------\n+void wallet2::check_acc_out_precomp_once(const tx_out \u0026o, const crypto::key_derivation \u0026derivation, const std::vector\u003ccrypto::key_derivation\u003e \u0026additional_derivations, size_t i, tx_scan_info_t \u0026tx_scan_info, bool \u0026already_seen) const\n+{\n+  tx_scan_info.received = boost::none;\n+  if (already_seen)\n+    return;\n+  check_acc_out_precomp(o, derivation, additional_derivations, i, tx_scan_info);\n+  if (tx_scan_info.received)\n+    already_seen = true;\n+}\n+//----------------------------------------------------------------------------------------------------\n static uint64_t decodeRct(const rct::rctSig \u0026 rv, const crypto::key_derivation \u0026derivation, unsigned int i, rct::key \u0026 mask, hw::device \u0026hwdev)\n {\n   crypto::secret_key scalar1;\n@@ -1110,7 +1120,7 @@ void wallet2::process_new_transaction(const crypto::hash \u0026txid, const cryptonote\n   // Don't try to extract tx public key if tx has no ouputs\n   size_t pk_index = 0;\n   std::vector\u003ctx_scan_info_t\u003e tx_scan_info(tx.vout.size());\n-  std::unordered_set\u003ccrypto::public_key\u003e public_keys_seen;\n+  std::deque\u003cbool\u003e output_found(tx.vout.size(), false);\n   while (!tx.vout.empty())\n   {\n     // if tx.vout is not empty, we loop through all tx pubkeys\n@@ -1126,13 +1136,6 @@ void wallet2::process_new_transaction(const crypto::hash \u0026txid, const cryptonote\n       break;\n     }\n \n-    if (public_keys_seen.find(pub_key_field.pub_key) != public_keys_seen.end())\n-    {\n-      MWARNING(\"The same transaction pubkey is present more than once, ignoring extra instance\");\n-      continue;\n-    }\n-    public_keys_seen.insert(pub_key_field.pub_key);\n-\n     int num_vouts_received = 0;\n     tx_pub_key = pub_key_field.pub_key;\n     tools::threadpool\u0026 tpool = tools::threadpool::getInstance();\n@@ -1172,7 +1175,7 @@ void wallet2::process_new_transaction(const crypto::hash \u0026txid, const cryptonote\n     }\n     else if (miner_tx \u0026\u0026 m_refresh_type == RefreshOptimizeCoinbase)\n     {\n-      check_acc_out_precomp(tx.vout[0], derivation, additional_derivations, 0, tx_scan_info[0]);\n+      check_acc_out_precomp_once(tx.vout[0], derivation, additional_derivations, 0, tx_scan_info[0], output_found[0]);\n       THROW_WALLET_EXCEPTION_IF(tx_scan_info[0].error, error::acc_outs_lookup_error, tx, tx_pub_key, m_account.get_keys());\n \n       // this assumes that the miner tx pays a single address\n@@ -1182,8 +1185,8 @@ void wallet2::process_new_transaction(const crypto::hash \u0026txid, const cryptonote\n         // the first one was already checked\n         for (size_t i = 1; i \u003c tx.vout.size(); ++i)\n         {\n-          tpool.submit(\u0026waiter, boost::bind(\u0026wallet2::check_acc_out_precomp, this, std::cref(tx.vout[i]), std::cref(derivation), std::cref(additional_derivations), i,\n-            std::ref(tx_scan_info[i])));\n+          tpool.submit(\u0026waiter, boost::bind(\u0026wallet2::check_acc_out_precomp_once, this, std::cref(tx.vout[i]), std::cref(derivation), std::cref(additional_derivations), i,\n+            std::ref(tx_scan_info[i]), std::ref(output_found[i])));\n         }\n         waiter.wait();\n         // then scan all outputs from 0\n@@ -1205,8 +1208,8 @@ void wallet2::process_new_transaction(const crypto::hash \u0026txid, const cryptonote\n     {\n       for (size_t i = 0; i \u003c tx.vout.size(); ++i)\n       {\n-        tpool.submit(\u0026waiter, boost::bind(\u0026wallet2::check_acc_out_precomp, this, std::cref(tx.vout[i]), std::cref(derivation), std::cref(additional_derivations), i,\n-            std::ref(tx_scan_info[i])));\n+        tpool.submit(\u0026waiter, boost::bind(\u0026wallet2::check_acc_out_precomp_once, this, std::cref(tx.vout[i]), std::cref(derivation), std::cref(additional_derivations), i,\n+            std::ref(tx_scan_info[i]), std::ref(output_found[i])));\n       }\n       waiter.wait();\n \n@@ -1227,7 +1230,7 @@ void wallet2::process_new_transaction(const crypto::hash \u0026txid, const cryptonote\n     {\n       for (size_t i = 0; i \u003c tx.vout.size(); ++i)\n       {\n-        check_acc_out_precomp(tx.vout[i], derivation, additional_derivations, i, tx_scan_info[i]);\n+        check_acc_out_precomp_once(tx.vout[i], derivation, additional_derivations, i, tx_scan_info[i], output_found[i]);\n         THROW_WALLET_EXCEPTION_IF(tx_scan_info[i].error, error::acc_outs_lookup_error, tx, tx_pub_key, m_account.get_keys());\n         if (tx_scan_info[i].received)\n         {\ndiff --git a/src/wallet/wallet2.h b/src/wallet/wallet2.h\nindex 97a5df5..59b4500 100644\n--- a/src/wallet/wallet2.h\n+++ b/src/wallet/wallet2.h\n@@ -1112,6 +1112,7 @@ namespace tools\n     bool generate_chacha_key_from_secret_keys(crypto::chacha_key \u0026key) const;\n     crypto::hash get_payment_id(const pending_tx \u0026ptx) const;\n     void check_acc_out_precomp(const cryptonote::tx_out \u0026o, const crypto::key_derivation \u0026derivation, const std::vector\u003ccrypto::key_derivation\u003e \u0026additional_derivations, size_t i, tx_scan_info_t \u0026tx_scan_info) const;\n+    void check_acc_out_precomp_once(const cryptonote::tx_out \u0026o, const crypto::key_derivation \u0026derivation, const std::vector\u003ccrypto::key_derivation\u003e \u0026additional_derivations, size_t i, tx_scan_info_t \u0026tx_scan_info, bool \u0026already_seen) const;\n     void parse_block_round(const cryptonote::blobdata \u0026blob, cryptonote::block \u0026bl, crypto::hash \u0026bl_id, bool \u0026error) const;\n     uint64_t get_upper_transaction_size_limit() const;\n     std::vector\u003cuint64_t\u003e get_unspent_amounts_vector() const;\n```","markdown_message":"\u003cp\u003eBetter patch after discussion with the reporter:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e\u003cspan class=\"p\"\u003ecommit 58f28cadf8318d7a0e0e8fd85f257acfef34f62e\nAuthor: moneromooo-monero \u0026lt;moneromooo-monero@users.noreply.github.com\u0026gt;\nDate:   Sun Jul 8 11:01:13 2018 +0100\n\u003c/span\u003e\n    wallet2: ensure outputs are processed only once\n\n    This should be proof against any way one might get to multiple\n    processing, such as generating the same derivation from the\n    same pubkey, etc\n\ndiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\n\u003cspan class=\"gh\"\u003eindex 4477b97..2de92a5 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/src/wallet/wallet2.cpp\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/src/wallet/wallet2.cpp\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -1030,6 +1030,16 @@\u003c/span\u003e void wallet2::check_acc_out_precomp(const tx_out \u0026amp;o, const crypto::key_derivatio\n   tx_scan_info.error = false;\n }\n //----------------------------------------------------------------------------------------------------\n\u003cspan class=\"gi\"\u003e+void wallet2::check_acc_out_precomp_once(const tx_out \u0026amp;o, const crypto::key_derivation \u0026amp;derivation, const std::vector\u0026lt;crypto::key_derivation\u0026gt; \u0026amp;additional_derivations, size_t i, tx_scan_info_t \u0026amp;tx_scan_info, bool \u0026amp;already_seen) const\n+{\n+  tx_scan_info.received = boost::none;\n+  if (already_seen)\n+    return;\n+  check_acc_out_precomp(o, derivation, additional_derivations, i, tx_scan_info);\n+  if (tx_scan_info.received)\n+    already_seen = true;\n+}\n+//----------------------------------------------------------------------------------------------------\n\u003c/span\u003e static uint64_t decodeRct(const rct::rctSig \u0026amp; rv, const crypto::key_derivation \u0026amp;derivation, unsigned int i, rct::key \u0026amp; mask, hw::device \u0026amp;hwdev)\n {\n   crypto::secret_key scalar1;\n\u003cspan class=\"p\"\u003e@@ -1110,7 +1120,7 @@\u003c/span\u003e void wallet2::process_new_transaction(const crypto::hash \u0026amp;txid, const cryptonote\n   // Don\u0026#39;t try to extract tx public key if tx has no ouputs\n   size_t pk_index = 0;\n   std::vector\u0026lt;tx_scan_info_t\u0026gt; tx_scan_info(tx.vout.size());\n\u003cspan class=\"gd\"\u003e-  std::unordered_set\u0026lt;crypto::public_key\u0026gt; public_keys_seen;\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+  std::deque\u0026lt;bool\u0026gt; output_found(tx.vout.size(), false);\n\u003c/span\u003e   while (!tx.vout.empty())\n   {\n     // if tx.vout is not empty, we loop through all tx pubkeys\n\u003cspan class=\"p\"\u003e@@ -1126,13 +1136,6 @@\u003c/span\u003e void wallet2::process_new_transaction(const crypto::hash \u0026amp;txid, const cryptonote\n       break;\n     }\n\n-    if (public_keys_seen.find(pub_key_field.pub_key) != public_keys_seen.end())\n\u003cspan class=\"gd\"\u003e-    {\n-      MWARNING(\u0026quot;The same transaction pubkey is present more than once, ignoring extra instance\u0026quot;);\n-      continue;\n-    }\n-    public_keys_seen.insert(pub_key_field.pub_key);\n-\n\u003c/span\u003e     int num_vouts_received = 0;\n     tx_pub_key = pub_key_field.pub_key;\n     tools::threadpool\u0026amp; tpool = tools::threadpool::getInstance();\n\u003cspan class=\"p\"\u003e@@ -1172,7 +1175,7 @@\u003c/span\u003e void wallet2::process_new_transaction(const crypto::hash \u0026amp;txid, const cryptonote\n     }\n     else if (miner_tx \u0026amp;\u0026amp; m_refresh_type == RefreshOptimizeCoinbase)\n     {\n\u003cspan class=\"gd\"\u003e-      check_acc_out_precomp(tx.vout[0], derivation, additional_derivations, 0, tx_scan_info[0]);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+      check_acc_out_precomp_once(tx.vout[0], derivation, additional_derivations, 0, tx_scan_info[0], output_found[0]);\n\u003c/span\u003e       THROW_WALLET_EXCEPTION_IF(tx_scan_info[0].error, error::acc_outs_lookup_error, tx, tx_pub_key, m_account.get_keys());\n\n       // this assumes that the miner tx pays a single address\n\u003cspan class=\"p\"\u003e@@ -1182,8 +1185,8 @@\u003c/span\u003e void wallet2::process_new_transaction(const crypto::hash \u0026amp;txid, const cryptonote\n         // the first one was already checked\n         for (size_t i = 1; i \u0026lt; tx.vout.size(); ++i)\n         {\n\u003cspan class=\"gd\"\u003e-          tpool.submit(\u0026amp;waiter, boost::bind(\u0026amp;wallet2::check_acc_out_precomp, this, std::cref(tx.vout[i]), std::cref(derivation), std::cref(additional_derivations), i,\n-            std::ref(tx_scan_info[i])));\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+          tpool.submit(\u0026amp;waiter, boost::bind(\u0026amp;wallet2::check_acc_out_precomp_once, this, std::cref(tx.vout[i]), std::cref(derivation), std::cref(additional_derivations), i,\n+            std::ref(tx_scan_info[i]), std::ref(output_found[i])));\n\u003c/span\u003e         }\n         waiter.wait();\n         // then scan all outputs from 0\n\u003cspan class=\"p\"\u003e@@ -1205,8 +1208,8 @@\u003c/span\u003e void wallet2::process_new_transaction(const crypto::hash \u0026amp;txid, const cryptonote\n     {\n       for (size_t i = 0; i \u0026lt; tx.vout.size(); ++i)\n       {\n\u003cspan class=\"gd\"\u003e-        tpool.submit(\u0026amp;waiter, boost::bind(\u0026amp;wallet2::check_acc_out_precomp, this, std::cref(tx.vout[i]), std::cref(derivation), std::cref(additional_derivations), i,\n-            std::ref(tx_scan_info[i])));\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+        tpool.submit(\u0026amp;waiter, boost::bind(\u0026amp;wallet2::check_acc_out_precomp_once, this, std::cref(tx.vout[i]), std::cref(derivation), std::cref(additional_derivations), i,\n+            std::ref(tx_scan_info[i]), std::ref(output_found[i])));\n\u003c/span\u003e       }\n       waiter.wait();\n\n@@ -1227,7 +1230,7 @@ void wallet2::process_new_transaction(const crypto::hash \u0026amp;txid, const cryptonote\n     {\n       for (size_t i = 0; i \u0026lt; tx.vout.size(); ++i)\n       {\n\u003cspan class=\"gd\"\u003e-        check_acc_out_precomp(tx.vout[i], derivation, additional_derivations, i, tx_scan_info[i]);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+        check_acc_out_precomp_once(tx.vout[i], derivation, additional_derivations, i, tx_scan_info[i], output_found[i]);\n\u003c/span\u003e         THROW_WALLET_EXCEPTION_IF(tx_scan_info[i].error, error::acc_outs_lookup_error, tx, tx_pub_key, m_account.get_keys());\n         if (tx_scan_info[i].received)\n         {\n\u003cspan class=\"gh\"\u003ediff --git a/src/wallet/wallet2.h b/src/wallet/wallet2.h\nindex 97a5df5..59b4500 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/src/wallet/wallet2.h\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/src/wallet/wallet2.h\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -1112,6 +1112,7 @@\u003c/span\u003e namespace tools\n     bool generate_chacha_key_from_secret_keys(crypto::chacha_key \u0026amp;key) const;\n     crypto::hash get_payment_id(const pending_tx \u0026amp;ptx) const;\n     void check_acc_out_precomp(const cryptonote::tx_out \u0026amp;o, const crypto::key_derivation \u0026amp;derivation, const std::vector\u0026lt;crypto::key_derivation\u0026gt; \u0026amp;additional_derivations, size_t i, tx_scan_info_t \u0026amp;tx_scan_info) const;\n\u003cspan class=\"gi\"\u003e+    void check_acc_out_precomp_once(const cryptonote::tx_out \u0026amp;o, const crypto::key_derivation \u0026amp;derivation, const std::vector\u0026lt;crypto::key_derivation\u0026gt; \u0026amp;additional_derivations, size_t i, tx_scan_info_t \u0026amp;tx_scan_info, bool \u0026amp;already_seen) const;\n\u003c/span\u003e     void parse_block_round(const cryptonote::blobdata \u0026amp;blob, cryptonote::block \u0026amp;bl, crypto::hash \u0026amp;bl_id, bool \u0026amp;error) const;\n     uint64_t get_upper_transaction_size_limit() const;\n     std::vector\u0026lt;uint64_t\u0026gt; get_unspent_amounts_vector() const;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2018-07-08T12:35:29.969Z","updated_at":"2018-07-08T12:36:15.108Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3013473,"is_internal":false,"editable":false,"type":"Activities::BugTriaged","message":"","markdown_message":"","automated_response":false,"created_at":"2018-07-08T13:02:40.265Z","updated_at":"2018-07-08T13:02:40.265Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3013968,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"That patch looks good to me.","markdown_message":"\u003cp\u003eThat patch looks good to me.\u003c/p\u003e\n","automated_response":false,"created_at":"2018-07-08T20:01:34.375Z","updated_at":"2018-07-08T20:01:34.375Z","actor":{"username":"phiren","cleared":false,"url":"/phiren","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":3105045,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"Hi @phiren, thank you for the report. This is fixed in https://github.com/monero-project/monero/releases/tag/v0.12.3.0. Please paste an XMR address if you want a bounty payout.","markdown_message":"\u003cp\u003eHi \u003ca href=\"/phiren\"\u003e@phiren\u003c/a\u003e, thank you for the report. This is fixed in \u003ca title=\"https://github.com/monero-project/monero/releases/tag/v0.12.3.0\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fmonero-project%2Fmonero%2Freleases%2Ftag%2Fv0.12.3.0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/monero-project/monero/releases/tag/v0.12.3.0\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e. Please paste an XMR address if you want a bounty payout.\u003c/p\u003e\n","automated_response":false,"created_at":"2018-07-27T10:19:33.734Z","updated_at":"2018-07-27T10:19:33.734Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"reporter":{"username":"phiren","url":"/phiren"},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":3105046,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2018-07-27T10:19:44.862Z","updated_at":"2018-07-27T10:19:44.862Z","first_to_agree":true,"actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":3107015,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for fixing this promptly.\n\nBounty Address: 4AKkgCVxvsz3x2LSaYCP5NA6H1Va24EJZWxFb8aDU3amPydnqomy66dFUAQArcwQRtexW2cRB9r6M1G7F5EBAvaQJfUR3iz","markdown_message":"\u003cp\u003eThanks for fixing this promptly.\u003c/p\u003e\n\n\u003cp\u003eBounty Address: 4AKkgCVxvsz3x2LSaYCP5NA6H1Va24EJZWxFb8aDU3amPydnqomy66dFUAQArcwQRtexW2cRB9r6M1G7F5EBAvaQJfUR3iz\u003c/p\u003e\n","automated_response":false,"created_at":"2018-07-27T21:28:22.740Z","updated_at":"2018-07-27T21:28:22.740Z","actor":{"username":"phiren","cleared":false,"url":"/phiren","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":3107017,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2018-07-27T21:28:34.429Z","updated_at":"2018-07-27T21:28:34.429Z","actor":{"username":"phiren","cleared":false,"url":"/phiren","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":3107018,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2018-07-27T21:28:34.532Z","updated_at":"2018-07-27T21:28:34.532Z","actor":{"username":"phiren","cleared":false,"url":"/phiren","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":3129943,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Sent 35 XMR: \u003cf119ce93d3ea78f0c48be09ce9f86a88ce2320e2317c94c213390322d3b3ebce\u003e","markdown_message":"\u003cp\u003eSent 35 XMR: \u0026lt;f119ce93d3ea78f0c48be09ce9f86a88ce2320e2317c94c213390322d3b3ebce\u0026gt;\u003c/p\u003e\n","automated_response":false,"created_at":"2018-08-01T19:00:52.396Z","updated_at":"2018-08-01T19:00:52.396Z","actor":{"username":"luigi1111w","cleared":false,"url":"/luigi1111w","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":3130814,"is_internal":false,"editable":false,"type":"Activities::SwagAwarded","message":"","markdown_message":"","automated_response":false,"created_at":"2018-08-02T00:10:09.071Z","updated_at":"2018-08-02T00:10:09.071Z","actor":{"url":"/monero","ibb":false,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Monero"}},"reporter":{"username":"phiren","url":"/phiren"},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}